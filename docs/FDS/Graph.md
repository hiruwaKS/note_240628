# 图论算法

## Term

* Please see [Graph Basis](../DM/Graph_Basis.md)

----

## 图的表示

* 邻接矩阵、关系矩阵、邻接表/链式前向星、
* 无向图的处理：一般当成两条有向边
* 如果要同时快速地计算有向图的入度和出度，可以保存两个表，或者用[Multilist](../FDS/Linear_Structure.md#multilist)
* 权的表示

----

## 拓扑排序

* 方案一：找到没有入度的结点，输出，然后再减少所有相邻结点（出结点）的入度；复杂度 $O(V^2)$
* 方案二：和方案一类似，但是使用一个 `队列/栈` ，初始化时存所有零入度结点，然后处理所有 `队列/栈` 中的元素，减少它们相邻的结点的入度，降为零就入 `队列/栈` 

* 方案二的时间复杂度为： $O(V+E)$；证明：每个结点加入队列一次，每个结点进行 `入度` 次减少操作

----

## 最短路

### 无权BFS

* 方案一：将 `起点` 距离标为 `0` ，其他均 `无穷大` ，从 `0` 开始增加 `当前距离` ，将所有等于 `当前距离` 的点的邻接点距离标为 `当前距离 + 1` ；复杂度 $O(V^2)$
* 方案二：和方案一类似，但是使用一个 `队列/栈` ，初始化时加入 `起点` ，然后处理所有 `队列/栈` 中的元素，如果邻接点距离 `无穷大`，就更新距离，并加入 `队列/栈` 

* 方案二的时间复杂度为： $O(V+E)$；证明：同*Topo排序*

### Dijkstra

* 不适用负边权。
* 概念：**源点**、（到源点的）**距离**、已知/未知顶点
* 下一个顶点：已知顶点的所有邻接点中，距离最小的
* 找到下一个 + 距离调整：

1. 暴力：$O(V)$ -> $O(V^2+E)$
2. 堆优化 with  `Decrease Key` ：$O(log V)$ -> $O(E log(V))$
3. 堆优化 with  `Insert` ：$O(log V)$ -> $O(E log(V))$，但需要 `E` 次 `DeleteMin` 和空间复杂度 `E`

#### 命题

* 引理0：到源点的有向边权最小的点的距离是该边的权
* 引理1：每次 `Dijkstra` 后所有未知顶点的距离大于等于产生的 `顶点h` 的距离：假设有一个 `未知顶点j` 可以通过 `路径i` 到达，那么 `路径i` 上必然出现前面有若干个顶点已知， `下一个顶点k` 未知的情况，而 `j` 的距离一定大于等于 `k` 的距离， `k` 的距离一定大于等于 `h` 的距离（否则k一定会被产生）
* 引理2：对于任意顶点，它的距离是所有顶点的距离到它的有向边的权（如果存在的话）的最小值
* 命题0： `Dijkstra` 给出的距离是最短路径的长度

??? note 证明
    假设 `Dijkstra` 产生的 `顶点h` 存在一条更短的路径，那么可知这条路径上， `h` 的 `上一个顶点k` 一定不是已知顶点， `k` 的距离大于等于 `h` 的距离，所以该路径一定大于等于 `h` 的距离，则 `h` 的距离对应的那条路径是最小的

* 命题1：最短路径上任何相邻两点的边权等于两点的距离差

#### 拓展

* 记录路径
* 记录路径条数

### Bellman-Ford

* 适用于负边权。
* 和 *Dijkstra* 的区别： *Dijkstra* 每次只会处理最小的一个邻接顶点，而 *Bellman-Ford* 处理所有（不是上一轮的）邻接顶点；另外，*Bellman-Ford* 最多只能松弛 `n` 轮
* 时间复杂度：$O(V \cdot E)$
* 第 `n+1` 轮可以用来找负值回路

### Acyclic Graphs

* 类似于 *Dijkstra* ，但不用优先队列
* 应用：*AOE* 中找 *Critical Path*

----

## 网络流问题

* 不能用贪心，需要"撤回"，residual graph
* 方案1：找无权路径，$O(E cap)$
* 方案2：找最大流路径, $O(E^2 log(V) log(cap))$
* 方案3：找最短路径, $O(E^2 V)$

----

## MST

### Kruskal

* 证明：如果有一个更小的生成树，总能调整若干条边让它包含 `Krustal` 的结果
* 复杂度：$O(E log(E))$

### Prim

* 证明：和 *Krustal* 证明类似
* 复杂度：$O(V^2)$（循环版本） / $O(E log(V))$（二叉堆版本，对于稀疏图是一个好的界）

----

## DFS

* DFS的应用广泛
* DFS可以进行拓扑排序

??? note "总结"
    Topological Sort, BFS, DFS 时间复杂度均为 $O(V + E)$
    Prim( sparse ver. ), Kruskal, Dijkstra 时间复杂度均为 $O(E\ log\ V) = O((E + V) log\ V)$

### DFS Tree

* DFS的结果是一颗树
* ***DFS树的边***：无向图的DFS树上，只能有树边和反向边；有向图的DFS树上，有树边、反向边、前向边、叉边（引用自[CSDN](https://blog.csdn.net/weixin_73113801/article/details/130911664)）
* DFS序：表示 DFS 的先后关系，若两个结点有祖先关系，则DFS序小的一定是祖先
* lowNum ：向下走，如果有反向边，就返回，走到的结点的DFS序

### 双连通分量

* 割点：如果根有两个元素及以上则是割点，其他点如果所有孩子的 lowNum 都小于自己的DFS序

### 欧拉回路，欧拉路径，哈密顿回路

* Fleury 算法： $O(V+E)$ ,判断欧拉回路是否存在
* 计数法
* *Hierholzer 算法*

### 强连通分量

* Tarjan 算法：DFS序和lowNum相等，有强连通分量
* *Kosaraju 算法*